window.SIDEBAR_ITEMS = {"constant":[["BREAKDOWN_TIMEOUT","The amount of time in blocks we require our counterparty wait to claim their money (ie time between when we, or our watchtower, must check for them having broadcast a theft transaction)."],["MIN_CLTV_EXPIRY_DELTA","The minimum number of blocks between an inbound HTLC’s CLTV and the corresponding outbound HTLC’s CLTV. The current default represents roughly seven hours of blocks at six blocks/hour."],["MIN_FINAL_CLTV_EXPIRY_DELTA","Minimum CLTV difference between the current block height and received inbound payments. Invoices generated for payment to us must set their `min_final_cltv_expiry_delta` field to at least this value."]],"enum":[["FailureCode","This enum is used to specify which error data to send to peers when failing back an HTLC using [`ChannelManager::fail_htlc_backwards_with_reason`]."],["PaymentSendFailure","If a payment fails to send, it can be in one of several states. This enum is returned as the Err() type describing which state the payment is in, see the description of individual enum states for more."]],"fn":[["provided_init_features","Fetches the set of [`InitFeatures`] flags which are provided by or required by [`ChannelManager`]."]],"struct":[["ChainParameters","Chain-related parameters used to construct a new `ChannelManager`."],["ChannelCounterparty","Channel parameters which apply to our counterparty. These are split out from [`ChannelDetails`] to better separate parameters."],["ChannelDetails","Details of a channel, as returned by ChannelManager::list_channels and ChannelManager::list_usable_channels"],["ChannelManager","Manager which keeps track of a number of channels and sends messages to the appropriate channel, also tracking HTLC preimages and forwarding onion packets appropriately."],["ChannelManagerReadArgs","Arguments for the creation of a ChannelManager that are not deserialized."],["CounterpartyForwardingInfo","Information needed for constructing an invoice route hint for this channel."],["InterceptId","An identifier used to uniquely identify an intercepted HTLC to LDK. (C-not exported) as we just use [u8; 32] directly"],["PaymentId","A payment identifier used to uniquely identify a payment to LDK. (C-not exported) as we just use [u8; 32] directly"],["PhantomRouteHints","Route hints used in constructing invoices for [phantom node payents]."]],"type":[["SimpleArcChannelManager","SimpleArcChannelManager is useful when you need a ChannelManager with a static lifetime, e.g. when you’re using lightning-net-tokio (since tokio::spawn requires parameters with static lifetimes). Other times you can afford a reference, which is more efficient, in which case SimpleRefChannelManager is the more appropriate type. Defining these type aliases prevents issues such as overly long function definitions. Note that the ChannelManager can take any type that implements KeysInterface or Router for its keys manager and router, respectively, but this type alias chooses the concrete types of KeysManager and DefaultRouter."],["SimpleRefChannelManager","SimpleRefChannelManager is a type alias for a ChannelManager reference, and is the reference counterpart to the SimpleArcChannelManager type alias. Use this type by default when you don’t need a ChannelManager with a static lifetime. You’ll need a static lifetime in cases such as usage of lightning-net-tokio (since tokio::spawn requires parameters with static lifetimes). But if this is not necessary, using a reference is more efficient. Defining these type aliases issues such as overly long function definitions. Note that the ChannelManager can take any type that implements KeysInterface or Router for its keys manager and router, respectively, but this type alias chooses the concrete types of KeysManager and DefaultRouter."]]};